@startuml Strategy_Pattern_Detail

!theme plain
skinparam dpi 300
skinparam classAttributeIconSize 0
skinparam classFontSize 11
skinparam packageStyle rectangle

title Strategy Pattern - PoliMarket Pricing Algorithms

' Definición de colores
!define STRATEGY_PATTERN #E6F3FF
!define CONTEXT_CLASS #E6FFE6
!define INTEGRATION #F0F8FF

' ========== STRATEGY PATTERN ==========
package "Strategy Pattern" STRATEGY_PATTERN {
    interface IPricingStrategy <<Strategy>> {
        + calculatePrice(basePrice: Double, context: PricingContext): Double
        + getStrategyName(): String
        + isApplicable(context: PricingContext): Boolean
        + getDiscountPercentage(context: PricingContext): Double
        + validateContext(context: PricingContext): Boolean
    }
    
    class PricingContext <<Context Data>> {
        + cliente: Cliente
        + producto: Producto
        + cantidad: Integer
        + fechaVenta: Date
        + tipoDescuento: String
        + temporada: String
        + metodoPago: String
        + historialCompras: List<Venta>
        + getClienteType(): String
        + isVIPClient(): Boolean
        + getTotalPurchaseHistory(): Double
    }
    
    class RegularPricingStrategy <<Concrete Strategy>> {
        - taxRate: Double
        + calculatePrice(basePrice: Double, context: PricingContext): Double
        + getStrategyName(): String
        + isApplicable(context: PricingContext): Boolean
        + getDiscountPercentage(context: PricingContext): Double
        + validateContext(context: PricingContext): Boolean
        - applyBasicTax(price: Double): Double
    }
    
    class VIPDiscountStrategy <<Concrete Strategy>> {
        - vipDiscountPercentage: Double
        - minimumPurchaseAmount: Double
        + calculatePrice(basePrice: Double, context: PricingContext): Double
        + getStrategyName(): String
        + isApplicable(context: PricingContext): Boolean
        + getDiscountPercentage(context: PricingContext): Double
        + validateContext(context: PricingContext): Boolean
        - calculateVIPDiscount(context: PricingContext): Double
        - validateVIPStatus(cliente: Cliente): Boolean
    }
    
    class VolumeDiscountStrategy <<Concrete Strategy>> {
        - volumeThresholds: Map<Integer, Double>
        - maxDiscountPercentage: Double
        + calculatePrice(basePrice: Double, context: PricingContext): Double
        + getStrategyName(): String
        + isApplicable(context: PricingContext): Boolean
        + getDiscountPercentage(context: PricingContext): Double
        + validateContext(context: PricingContext): Boolean
        - calculateVolumeDiscount(cantidad: Integer): Double
        - getVolumeThreshold(cantidad: Integer): Double
    }
    
    class SeasonalDiscountStrategy <<Concrete Strategy>> {
        - seasonalRates: Map<String, Double>
        - validSeasons: List<String>
        + calculatePrice(basePrice: Double, context: PricingContext): Double
        + getStrategyName(): String
        + isApplicable(context: PricingContext): Boolean
        + getDiscountPercentage(context: PricingContext): Double
        + validateContext(context: PricingContext): Boolean
        - getCurrentSeason(): String
        - getSeasonalRate(temporada: String): Double
    }
    
    class PaymentMethodStrategy <<Concrete Strategy>> {
        - paymentDiscounts: Map<String, Double>
        - supportedMethods: List<String>
        + calculatePrice(basePrice: Double, context: PricingContext): Double
        + getStrategyName(): String
        + isApplicable(context: PricingContext): Boolean
        + getDiscountPercentage(context: PricingContext): Double
        + validateContext(context: PricingContext): Boolean
        - getPaymentDiscount(metodoPago: String): Double
    }
}

' ========== STRATEGY MANAGEMENT ==========
package "Strategy Management" CONTEXT_CLASS {
    class StrategyManager <<Strategy Context>> {
        - strategies: List<IPricingStrategy>
        - defaultStrategy: IPricingStrategy
        - configManager: ConfigurationManager
        + addStrategy(strategy: IPricingStrategy): void
        + removeStrategy(strategyName: String): void
        + selectStrategy(context: PricingContext): IPricingStrategy
        + calculateOptimalPrice(basePrice: Double, context: PricingContext): Double
        + getAllApplicableStrategies(context: PricingContext): List<IPricingStrategy>
        - selectBestStrategy(applicableStrategies: List<IPricingStrategy>, context: PricingContext): IPricingStrategy
        - combineStrategies(strategies: List<IPricingStrategy>, context: PricingContext): Double
    }
    
    class PricingResult <<Result>> {
        + originalPrice: Double
        + finalPrice: Double
        + appliedStrategies: List<String>
        + totalDiscount: Double
        + discountBreakdown: Map<String, Double>
        + calculationTimestamp: Date
        + getDiscountPercentage(): Double
        + getSavings(): Double
    }
}

' ========== INTEGRATION WITH EXISTING SYSTEM ==========
package "System Integration" INTEGRATION {
    class VentasComponent <<Enhanced Component>> {
        - strategyManager: StrategyManager
        - eventPublisher: IEventPublisher
        - configManager: ConfigurationManager
        + processSale(request: CreateSaleRequest): ApiResponse<SaleProcessingResponse>
        + calculateTotal(details: List<SaleDetailRequest>): ApiResponse<Double>
        + calculatePriceWithStrategy(basePrice: Double, context: PricingContext): ApiResponse<PricingResult>
        + applyDiscount(saleId: String, discount: Double): ApiResponse<Venta>
        - buildPricingContext(request: CreateSaleRequest): PricingContext
        - selectOptimalPricingStrategy(context: PricingContext): IPricingStrategy
    }
    
    class Cliente <<Domain Entity>> {
        - id: String
        - nombre: String
        - tipoCliente: String
        - limiteCredito: Double
        - fechaRegistro: Date
        - totalCompras: Double
        + getDiscountEligibility(): DiscountEligibility
        + isVIP(): Boolean
        + getCreditLimit(): Double
        + getPurchaseHistory(): List<Venta>
        + getClientType(): String
    }
    
    class Venta <<Domain Entity>> {
        - id: String
        - fecha: Date
        - total: Double
        - descuento: Double
        - estado: String
        - pricingStrategy: String
        - pricingDetails: PricingResult
        + calcularTotal(): Double
        + aplicarDescuento(porcentaje: Double): void
        + getPricingStrategyUsed(): String
        + getPricingBreakdown(): Map<String, Double>
    }
}

' ========== RELATIONSHIPS ==========

' Strategy Pattern Relationships
IPricingStrategy <|.. RegularPricingStrategy
IPricingStrategy <|.. VIPDiscountStrategy
IPricingStrategy <|.. VolumeDiscountStrategy
IPricingStrategy <|.. SeasonalDiscountStrategy
IPricingStrategy <|.. PaymentMethodStrategy

' Strategy Management
StrategyManager o-- IPricingStrategy
StrategyManager ..> PricingResult : creates
StrategyManager --> PricingContext : uses

' System Integration
VentasComponent --> StrategyManager : uses
VentasComponent --> PricingContext : creates
VentasComponent --> Cliente : reads
VentasComponent --> Venta : updates
Venta --> PricingResult : stores

' Context Dependencies
PricingContext --> Cliente : references
PricingContext --> Producto : references

' ========== PATTERN BENEFITS ==========
note as PatternBenefits
    **Strategy Pattern Benefits**
    
    ✅ **Runtime Flexibility**: Change pricing algorithms dynamically
    ✅ **Extensibility**: Add new pricing strategies without modifying existing code
    ✅ **Testability**: Each strategy can be tested independently
    ✅ **Maintainability**: Pricing logic separated and organized
    ✅ **Configurability**: Strategies can be configured per client type
    ✅ **Combinability**: Multiple strategies can be combined
    
    **Business Value**:
    • Personalized pricing for different customer segments
    • Seasonal and promotional pricing flexibility
    • Volume-based discounts for bulk purchases
    • Payment method incentives
    • A/B testing of pricing strategies
end note

' ========== USAGE EXAMPLE ==========
note as UsageExample
    **Usage Example**:
    
    ```csharp
    // Build pricing context
    var context = new PricingContext {
        cliente = vipCustomer,
        producto = smartphone,
        cantidad = 5,
        temporada = "BlackFriday",
        metodoPago = "CreditCard"
    };
    
    // Calculate optimal price
    var strategy = strategyManager.selectStrategy(context);
    var result = strategy.calculatePrice(1000.0, context);
    
    // Result: $850 (VIP 10% + Volume 5% discount)
    ```
end note

PatternBenefits -[hidden]- UsageExample

@enduml
