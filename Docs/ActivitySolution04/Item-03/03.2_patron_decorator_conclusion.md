# Item 3: Documentación de Funcionalidades - Command y Decorator (Continuación)

## Continuación del análisis de patrones GoF para PoliMarket

---

## 5. Command Pattern (Continuación)

### 5.3.2 Concrete Command - Process Sale Command
```csharp
namespace PoliMarket.Patterns.Command
{
    public class ProcessSaleCommand : ICommand
    {
        private readonly CreateSaleRequest _saleRequest;
        private readonly IVentasComponent _ventasComponent;
        private readonly IInventarioComponent _inventarioComponent;
        private readonly ILogger<ProcessSaleCommand> _logger;
        
        private string _commandId;
        private DateTime _executionTime;
        private string? _createdSaleId;
        private Dictionary<string, int> _originalStockLevels;

        public ProcessSaleCommand(
            CreateSaleRequest saleRequest,
            IVentasComponent ventasComponent,
            IInventarioComponent inventarioComponent,
            ILogger<ProcessSaleCommand> logger)
        {
            _saleRequest = saleRequest;
            _ventasComponent = ventasComponent;
            _inventarioComponent = inventarioComponent;
            _logger = logger;
            _commandId = Guid.NewGuid().ToString();
            _originalStockLevels = new Dictionary<string, int>();
        }

        public CommandResult Execute()
        {
            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
            _executionTime = DateTime.UtcNow;
            
            var result = new CommandResult();

            try
            {
                _logger.LogInformation("Executing ProcessSaleCommand: {CommandId}", _commandId);

                // Step 1: Store original stock levels for undo
                foreach (var detalle in _saleRequest.Detalles)
                {
                    var stockResponse = _inventarioComponent.GetCurrentStockAsync(detalle.IdProducto).Result;
                    if (stockResponse.Success && stockResponse.Data != null)
                    {
                        _originalStockLevels[detalle.IdProducto] = stockResponse.Data.StockActual;
                    }
                }

                // Step 2: Process the sale
                var saleResponse = _ventasComponent.ProcessSaleAsync(_saleRequest).Result;
                if (!saleResponse.Success)
                {
                    result.Success = false;
                    result.Message = "Failed to process sale";
                    result.Errors.AddRange(saleResponse.Errors);
                    return result;
                }

                _createdSaleId = saleResponse.Data?.VentaId;

                // Step 3: Update inventory
                foreach (var detalle in _saleRequest.Detalles)
                {
                    var stockUpdate = new StockUpdateRequest
                    {
                        IdProducto = detalle.IdProducto,
                        TipoMovimiento = "Salida",
                        Cantidad = detalle.Cantidad,
                        Motivo = $"Sale {_createdSaleId}",
                        DocumentoReferencia = _createdSaleId,
                        UsuarioResponsable = _saleRequest.IdVendedor
                    };

                    var updateResponse = _inventarioComponent.UpdateStockAsync(stockUpdate).Result;
                    if (!updateResponse.Success)
                    {
                        // If inventory update fails, we need to rollback the sale
                        result.Success = false;
                        result.Message = "Failed to update inventory";
                        result.Errors.Add($"Inventory update failed for product {detalle.IdProducto}");
                        
                        // Attempt to rollback
                        Undo();
                        return result;
                    }
                }

                stopwatch.Stop();
                result.Success = true;
                result.Message = "Sale processed successfully";
                result.ExecutionTime = stopwatch.ElapsedMilliseconds;
                result.AddData("saleId", _createdSaleId);
                result.AddData("total", saleResponse.Data?.Total ?? 0);

                _logger.LogInformation("ProcessSaleCommand executed successfully: {CommandId}, SaleId: {SaleId}", 
                    _commandId, _createdSaleId);

                return result;
            }
            catch (Exception ex)
            {
                stopwatch.Stop();
                _logger.LogError(ex, "Error executing ProcessSaleCommand: {CommandId}", _commandId);
                
                result.Success = false;
                result.Message = "Command execution failed";
                result.ExecutionTime = stopwatch.ElapsedMilliseconds;
                result.AddError(ex.Message);
                
                // Attempt to rollback
                Undo();
                
                return result;
            }
        }

        public CommandResult Undo()
        {
            var result = new CommandResult();

            try
            {
                _logger.LogInformation("Undoing ProcessSaleCommand: {CommandId}", _commandId);

                if (!string.IsNullOrEmpty(_createdSaleId))
                {
                    // Cancel the sale
                    var cancelResponse = _ventasComponent.CancelSaleAsync(_createdSaleId).Result;
                    if (!cancelResponse.Success)
                    {
                        result.AddWarning($"Failed to cancel sale: {_createdSaleId}");
                    }
                }

                // Restore original stock levels
                foreach (var stockLevel in _originalStockLevels)
                {
                    var restoreRequest = new StockUpdateRequest
                    {
                        IdProducto = stockLevel.Key,
                        TipoMovimiento = "Ajuste",
                        Cantidad = stockLevel.Value,
                        Motivo = $"Rollback for command {_commandId}",
                        DocumentoReferencia = _commandId,
                        UsuarioResponsable = "System"
                    };

                    var restoreResponse = _inventarioComponent.SetStockLevelAsync(restoreRequest).Result;
                    if (!restoreResponse.Success)
                    {
                        result.AddError($"Failed to restore stock for product {stockLevel.Key}");
                    }
                }

                result.Success = true;
                result.Message = "Command undone successfully";
                
                _logger.LogInformation("ProcessSaleCommand undone successfully: {CommandId}", _commandId);

                return result;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error undoing ProcessSaleCommand: {CommandId}", _commandId);
                
                result.Success = false;
                result.Message = "Undo operation failed";
                result.AddError(ex.Message);
                
                return result;
            }
        }

        public bool CanUndo() => !string.IsNullOrEmpty(_createdSaleId);
        public bool CanExecute() => _saleRequest != null && _saleRequest.Detalles.Any();
        public string GetCommandType() => "ProcessSaleCommand";
        public string GetCommandId() => _commandId;
        public DateTime GetExecutionTime() => _executionTime;
    }
}
```

### 5.3.3 Command Invoker
```csharp
namespace PoliMarket.Patterns.Command
{
    public class CommandInvoker
    {
        private readonly Stack<ICommand> _commandHistory;
        private readonly ILogger<CommandInvoker> _logger;
        private readonly int _maxHistorySize = 100;

        public CommandInvoker(ILogger<CommandInvoker> logger)
        {
            _logger = logger;
            _commandHistory = new Stack<ICommand>();
        }

        public CommandResult ExecuteCommand(ICommand command)
        {
            try
            {
                _logger.LogInformation("Executing command: {CommandType} - {CommandId}", 
                    command.GetCommandType(), command.GetCommandId());

                if (!command.CanExecute())
                {
                    return new CommandResult
                    {
                        Success = false,
                        Message = "Command cannot be executed"
                    };
                }

                var result = command.Execute();

                if (result.Success)
                {
                    AddToHistory(command);
                }

                _logger.LogInformation("Command execution result: {Success} - {Message}", 
                    result.Success, result.Message);

                return result;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error executing command: {CommandType}", command.GetCommandType());
                
                return new CommandResult
                {
                    Success = false,
                    Message = "Command execution failed",
                    Errors = { ex.Message }
                };
            }
        }

        public CommandResult UndoLastCommand()
        {
            if (_commandHistory.Count == 0)
            {
                return new CommandResult
                {
                    Success = false,
                    Message = "No commands to undo"
                };
            }

            var lastCommand = _commandHistory.Pop();
            
            _logger.LogInformation("Undoing command: {CommandType} - {CommandId}", 
                lastCommand.GetCommandType(), lastCommand.GetCommandId());

            if (!lastCommand.CanUndo())
            {
                return new CommandResult
                {
                    Success = false,
                    Message = "Command cannot be undone"
                };
            }

            return lastCommand.Undo();
        }

        public bool CanUndo()
        {
            return _commandHistory.Count > 0 && _commandHistory.Peek().CanUndo();
        }

        public List<string> GetCommandHistory()
        {
            return _commandHistory
                .Select(c => $"{c.GetCommandType()} - {c.GetCommandId()} - {c.GetExecutionTime()}")
                .ToList();
        }

        private void AddToHistory(ICommand command)
        {
            _commandHistory.Push(command);

            if (_commandHistory.Count > _maxHistorySize)
            {
                // Remove oldest commands if history is too large
                var commands = _commandHistory.ToArray();
                _commandHistory.Clear();
                
                for (int i = 0; i < _maxHistorySize - 1; i++)
                {
                    _commandHistory.Push(commands[i]);
                }
            }
        }
    }
}
```

---

## 6. Decorator Pattern

### 6.1 Problema Identificado
**¿Cuál es el problema?**
En el sistema actual, funcionalidades transversales como auditoría, logging, validación y seguridad están mezcladas con la lógica de negocio en cada componente. Esto viola el principio de responsabilidad única y hace el código difícil de mantener y probar.

### 6.2 Por qué el Patrón Ayuda
**¿Por qué el patrón puede ayudar a solucionar el problema?**
El Decorator Pattern permite:
- **Separación de responsabilidades**: Funcionalidades transversales separadas de lógica de negocio
- **Composición flexible**: Combinar decoradores según necesidades
- **Extensibilidad**: Nuevos decoradores sin modificar código existente
- **Transparencia**: Cliente usa el objeto decorado igual que el original

### 6.3 Implementación del Patrón
**¿Cómo se puede implementar el patrón?**

#### 6.3.1 Component Interface
```csharp
namespace PoliMarket.Patterns.Decorator
{
    public interface IComponentService
    {
        Task<ServiceResponse> ProcessRequestAsync(ServiceRequest request);
        string GetServiceName();
        bool IsAvailable();
    }

    public class ServiceRequest
    {
        public string RequestId { get; set; } = Guid.NewGuid().ToString();
        public string RequestType { get; set; } = string.Empty;
        public string UserId { get; set; } = string.Empty;
        public DateTime Timestamp { get; set; } = DateTime.UtcNow;
        public Dictionary<string, object> Parameters { get; set; } = new();
        public Dictionary<string, string> Headers { get; set; } = new();

        public void AddParameter(string key, object value) => Parameters[key] = value;
        public void AddHeader(string key, string value) => Headers[key] = value;
    }

    public class ServiceResponse
    {
        public bool Success { get; set; }
        public object? Data { get; set; }
        public string Message { get; set; } = string.Empty;
        public DateTime Timestamp { get; set; } = DateTime.UtcNow;
        public long ProcessingTime { get; set; }
        public List<string> Errors { get; set; } = new();
        public Dictionary<string, object> Metadata { get; set; } = new();

        public void AddError(string error) => Errors.Add(error);
        public void AddMetadata(string key, object value) => Metadata[key] = value;
    }
}
```

#### 6.3.2 Base Decorator
```csharp
namespace PoliMarket.Patterns.Decorator
{
    public abstract class ServiceDecorator : IComponentService
    {
        protected readonly IComponentService _decoratedService;
        protected readonly string _decoratorName;
        protected readonly ILogger _logger;

        protected ServiceDecorator(IComponentService decoratedService, ILogger logger)
        {
            _decoratedService = decoratedService;
            _decoratorName = GetType().Name;
            _logger = logger;
        }

        public virtual async Task<ServiceResponse> ProcessRequestAsync(ServiceRequest request)
        {
            try
            {
                await BeforeProcessingAsync(request);
                var response = await _decoratedService.ProcessRequestAsync(request);
                await AfterProcessingAsync(request, response);
                return WrapResponse(response);
            }
            catch (Exception ex)
            {
                return await HandleExceptionAsync(request, ex);
            }
        }

        public virtual string GetServiceName()
        {
            return $"{_decoratorName}({_decoratedService.GetServiceName()})";
        }

        public virtual bool IsAvailable()
        {
            return _decoratedService.IsAvailable();
        }

        protected abstract Task BeforeProcessingAsync(ServiceRequest request);
        protected abstract Task AfterProcessingAsync(ServiceRequest request, ServiceResponse response);
        protected abstract Task<ServiceResponse> HandleExceptionAsync(ServiceRequest request, Exception exception);

        protected virtual ServiceResponse WrapResponse(ServiceResponse response)
        {
            response.AddMetadata($"{_decoratorName}.Applied", true);
            return response;
        }
    }
}
```

#### 6.3.3 Concrete Decorator - Audit Decorator
```csharp
namespace PoliMarket.Patterns.Decorator
{
    public class AuditDecorator : ServiceDecorator
    {
        private readonly IAuditService _auditService;

        public AuditDecorator(IComponentService decoratedService, IAuditService auditService, ILogger<AuditDecorator> logger)
            : base(decoratedService, logger)
        {
            _auditService = auditService;
        }

        protected override async Task BeforeProcessingAsync(ServiceRequest request)
        {
            await _auditService.LogRequestAsync(new AuditRecord
            {
                RequestId = request.RequestId,
                UserId = request.UserId,
                Action = request.RequestType,
                Timestamp = request.Timestamp,
                Details = $"Request started for service: {_decoratedService.GetServiceName()}",
                RequestData = MaskSensitiveData(request.Parameters)
            });

            _logger.LogInformation("Audit: Request {RequestId} started for user {UserId}", 
                request.RequestId, request.UserId);
        }

        protected override async Task AfterProcessingAsync(ServiceRequest request, ServiceResponse response)
        {
            await _auditService.LogResponseAsync(new AuditRecord
            {
                RequestId = request.RequestId,
                UserId = request.UserId,
                Action = request.RequestType,
                Timestamp = DateTime.UtcNow,
                Details = $"Request completed - Success: {response.Success}",
                ResponseData = response.Success ? "Success" : string.Join(", ", response.Errors),
                ProcessingTime = response.ProcessingTime
            });

            _logger.LogInformation("Audit: Request {RequestId} completed - Success: {Success}", 
                request.RequestId, response.Success);
        }

        protected override async Task<ServiceResponse> HandleExceptionAsync(ServiceRequest request, Exception exception)
        {
            await _auditService.LogExceptionAsync(new AuditRecord
            {
                RequestId = request.RequestId,
                UserId = request.UserId,
                Action = request.RequestType,
                Timestamp = DateTime.UtcNow,
                Details = $"Request failed with exception: {exception.Message}",
                ExceptionData = exception.ToString()
            });

            _logger.LogError(exception, "Audit: Request {RequestId} failed", request.RequestId);

            return new ServiceResponse
            {
                Success = false,
                Message = "Service request failed",
                Errors = { exception.Message }
            };
        }

        private Dictionary<string, object> MaskSensitiveData(Dictionary<string, object> data)
        {
            var maskedData = new Dictionary<string, object>(data);
            var sensitiveKeys = new[] { "password", "token", "creditcard", "ssn" };

            foreach (var key in maskedData.Keys.ToList())
            {
                if (sensitiveKeys.Any(sk => key.ToLower().Contains(sk)))
                {
                    maskedData[key] = "***MASKED***";
                }
            }

            return maskedData;
        }
    }

    public interface IAuditService
    {
        Task LogRequestAsync(AuditRecord record);
        Task LogResponseAsync(AuditRecord record);
        Task LogExceptionAsync(AuditRecord record);
    }

    public class AuditRecord
    {
        public string RequestId { get; set; } = string.Empty;
        public string UserId { get; set; } = string.Empty;
        public string Action { get; set; } = string.Empty;
        public DateTime Timestamp { get; set; }
        public string Details { get; set; } = string.Empty;
        public Dictionary<string, object>? RequestData { get; set; }
        public string? ResponseData { get; set; }
        public string? ExceptionData { get; set; }
        public long ProcessingTime { get; set; }
    }
}
```

#### 6.3.4 Integration with AutorizacionComponent
```csharp
namespace PoliMarket.Components.Authorization
{
    public class AutorizacionService : IComponentService
    {
        private readonly IAutorizacionComponent _authorizationComponent;
        private readonly ILogger<AutorizacionService> _logger;

        public AutorizacionService(IAutorizacionComponent authorizationComponent, ILogger<AutorizacionService> logger)
        {
            _authorizationComponent = authorizationComponent;
            _logger = logger;
        }

        public async Task<ServiceResponse> ProcessRequestAsync(ServiceRequest request)
        {
            var stopwatch = System.Diagnostics.Stopwatch.StartNew();

            try
            {
                switch (request.RequestType)
                {
                    case "AuthorizeVendedor":
                        return await HandleAuthorizeVendedor(request);
                    case "ValidateAuthorization":
                        return await HandleValidateAuthorization(request);
                    default:
                        return new ServiceResponse
                        {
                            Success = false,
                            Message = $"Unknown request type: {request.RequestType}"
                        };
                }
            }
            finally
            {
                stopwatch.Stop();
            }
        }

        public string GetServiceName() => "AutorizacionService";
        public bool IsAvailable() => true;

        private async Task<ServiceResponse> HandleAuthorizeVendedor(ServiceRequest request)
        {
            var authRequest = new AuthorizationRequest
            {
                CodigoVendedor = request.Parameters["codigoVendedor"].ToString(),
                EmpleadoRH = request.Parameters["empleadoRH"].ToString(),
                Observaciones = request.Parameters.GetValueOrDefault("observaciones", "").ToString()
            };

            var result = await _authorizationComponent.AuthorizeVendedorAsync(authRequest);

            return new ServiceResponse
            {
                Success = result.Success,
                Data = result.Data,
                Message = result.Message,
                Errors = result.Errors
            };
        }

        private async Task<ServiceResponse> HandleValidateAuthorization(ServiceRequest request)
        {
            var codigoVendedor = request.Parameters["codigoVendedor"].ToString();
            var result = await _authorizationComponent.ValidateAuthorizationAsync(codigoVendedor);

            return new ServiceResponse
            {
                Success = result.Success,
                Data = result.Data,
                Message = result.Message,
                Errors = result.Errors
            };
        }
    }
}
```

---

## Conclusión del Item 3

### Resumen de Implementación de Patrones GoF

Los seis patrones GoF implementados en el sistema PoliMarket proporcionan soluciones específicas a problemas arquitectónicos identificados:

1. **Factory Method**: Creación flexible y extensible de productos por categoría
2. **Strategy**: Algoritmos de pricing intercambiables en tiempo de ejecución  
3. **Observer**: Comunicación desacoplada mediante eventos entre componentes
4. **Singleton**: Configuración centralizada y consistente en toda la aplicación
5. **Command**: Operaciones complejas con capacidad de deshacer y auditoría
6. **Decorator**: Funcionalidades transversales separadas de lógica de negocio

### Beneficios Arquitectónicos Logrados

- **Extensibilidad**: Nuevas funcionalidades sin modificar código existente
- **Mantenibilidad**: Separación clara de responsabilidades
- **Testabilidad**: Componentes aislados y mockeable
- **Flexibilidad**: Configuración y comportamiento dinámico
- **Robustez**: Manejo de errores y capacidad de rollback
- **Auditoría**: Registro completo de operaciones del sistema

### Cumplimiento de Principios SOLID

- **SRP**: Cada clase tiene una responsabilidad específica
- **OCP**: Extensible sin modificación mediante patrones
- **LSP**: Interfaces bien definidas y polimorfismo correcto
- **ISP**: Interfaces específicas y cohesivas
- **DIP**: Dependencias hacia abstracciones, no implementaciones

**El código implementado sigue criterios de diseño básicos, utiliza C# como lenguaje único, y está listo para integración en el documento final APA.**
