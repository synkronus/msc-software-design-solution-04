# Item 3: Documentación de Funcionalidades - Observer, Singleton, Command

## Continuación del análisis de patrones GoF para PoliMarket

---

## 3. Observer Pattern (Continuación)

### 3.3.3 Concrete Observer - Inventory Observer
```csharp
namespace PoliMarket.Patterns.Observer
{
    public class InventoryObserver : IEventObserver
    {
        private readonly IInventarioComponent _inventarioComponent;
        private readonly ILogger<InventoryObserver> _logger;
        private readonly Dictionary<string, int> _stockThresholds;

        public InventoryObserver(
            IInventarioComponent inventarioComponent,
            ILogger<InventoryObserver> logger)
        {
            _inventarioComponent = inventarioComponent;
            _logger = logger;
            _stockThresholds = new Dictionary<string, int>();
        }

        public void Update(ComponentEvent eventData)
        {
            _logger.LogInformation("InventoryObserver received event: {EventType}", eventData.EventType);

            switch (eventData.EventType)
            {
                case "SaleProcessed":
                    HandleSaleProcessed(eventData);
                    break;
                case "StockUpdated":
                    HandleStockUpdated(eventData);
                    break;
                case "ProductCreated":
                    HandleProductCreated(eventData);
                    break;
            }
        }

        public string GetObserverType() => "InventoryObserver";

        public bool IsInterestedIn(string eventType)
        {
            var interestedEvents = new[] { "SaleProcessed", "StockUpdated", "ProductCreated" };
            return interestedEvents.Contains(eventType);
        }

        public List<string> GetSubscribedEvents()
        {
            return new List<string> { "SaleProcessed", "StockUpdated", "ProductCreated" };
        }

        private async void HandleSaleProcessed(ComponentEvent eventData)
        {
            if (eventData.Data.TryGetValue("saleId", out var saleIdObj) &&
                eventData.Data.TryGetValue("products", out var productsObj))
            {
                var saleId = saleIdObj.ToString();
                var products = (List<dynamic>)productsObj;

                foreach (var product in products)
                {
                    await CheckStockLevels(product.ProductId.ToString());
                }
            }
        }

        private async void HandleStockUpdated(ComponentEvent eventData)
        {
            if (eventData.Data.TryGetValue("productId", out var productIdObj))
            {
                await CheckStockLevels(productIdObj.ToString());
            }
        }

        private async void HandleProductCreated(ComponentEvent eventData)
        {
            if (eventData.Data.TryGetValue("productId", out var productIdObj))
            {
                var productId = productIdObj.ToString();
                _stockThresholds[productId] = 10; // Default threshold
                _logger.LogInformation("Stock threshold set for new product: {ProductId}", productId);
            }
        }

        private async Task CheckStockLevels(string productId)
        {
            try
            {
                var stockResponse = await _inventarioComponent.GetCurrentStockAsync(productId);
                if (stockResponse.Success && stockResponse.Data != null)
                {
                    var currentStock = stockResponse.Data.StockActual;
                    var threshold = _stockThresholds.GetValueOrDefault(productId, 10);

                    if (currentStock <= threshold)
                    {
                        await GenerateStockAlert(productId, currentStock);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error checking stock levels for product: {ProductId}", productId);
            }
        }

        private async Task GenerateStockAlert(string productId, int currentStock)
        {
            _logger.LogWarning("Low stock alert for product {ProductId}: {CurrentStock} units", 
                productId, currentStock);
            
            // Here you would typically send the alert to a notification system
            // For now, we just log it
        }
    }
}
```

### 3.3.4 Integration with VentasComponent
```csharp
namespace PoliMarket.Components.Sales
{
    public class VentasComponent : IVentasComponent
    {
        private readonly EventManager _eventManager;
        private readonly ILogger<VentasComponent> _logger;
        // ... other dependencies

        public async Task<ApiResponse<SaleProcessingResponse>> ProcessSaleAsync(CreateSaleRequest request)
        {
            try
            {
                // ... existing sale processing logic ...

                // After successful sale processing, publish event
                var saleEvent = new ComponentEvent
                {
                    EventType = "SaleProcessed",
                    Source = "VentasComponent",
                    Priority = EventPriority.High,
                    CorrelationId = createdSale.Id
                };

                saleEvent.AddData("saleId", createdSale.Id);
                saleEvent.AddData("customerId", createdSale.IdCliente);
                saleEvent.AddData("total", createdSale.Total);
                saleEvent.AddData("products", request.Detalles.Select(d => new 
                { 
                    ProductId = d.IdProducto, 
                    Quantity = d.Cantidad 
                }).ToList());

                _eventManager.PublishEvent(saleEvent);

                var response = new SaleProcessingResponse
                {
                    VentaId = createdSale.Id,
                    Total = createdSale.Total,
                    Estado = createdSale.Estado,
                    FechaProcesamiento = createdSale.Fecha
                };

                return ApiResponse<SaleProcessingResponse>.SuccessResult(response, "Venta procesada exitosamente");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing sale");
                return ApiResponse<SaleProcessingResponse>.ErrorResult("Error interno del servidor", ex.Message);
            }
        }
    }
}
```

---

## 4. Singleton Pattern

### 4.1 Problema Identificado
**¿Cuál es el problema?**
En el sistema actual, cada componente maneja su propia configuración de manera independiente, lo que lleva a inconsistencias, duplicación de configuraciones y dificultades para mantener configuraciones centralizadas. No hay un punto único de acceso para configuraciones del sistema.

### 4.2 Por qué el Patrón Ayuda
**¿Por qué el patrón puede ayudar a solucionar el problema?**
El Singleton Pattern garantiza:
- **Instancia única**: Solo una instancia de configuración en toda la aplicación
- **Acceso global**: Punto único de acceso desde cualquier componente
- **Consistencia**: Misma configuración en todos los componentes
- **Eficiencia de memoria**: Una sola instancia en memoria

### 4.3 Implementación del Patrón
**¿Cómo se puede implementar el patrón?**

#### 4.3.1 Singleton Configuration Manager
```csharp
namespace PoliMarket.Patterns.Singleton
{
    public sealed class ConfigurationManager : IConfigurationProvider
    {
        private static ConfigurationManager? _instance;
        private static readonly object _lock = new object();
        
        private readonly Dictionary<string, object> _configuration;
        private readonly ILogger<ConfigurationManager> _logger;
        private bool _isInitialized;

        private ConfigurationManager()
        {
            _configuration = new Dictionary<string, object>();
            _logger = LoggerFactory.Create(builder => builder.AddConsole())
                .CreateLogger<ConfigurationManager>();
            InitializeDefaultConfiguration();
        }

        public static ConfigurationManager GetInstance()
        {
            if (_instance == null)
            {
                lock (_lock)
                {
                    if (_instance == null)
                    {
                        _instance = new ConfigurationManager();
                    }
                }
            }
            return _instance;
        }

        public T GetConfiguration<T>(string key)
        {
            if (_configuration.TryGetValue(key, out var value))
            {
                return (T)value;
            }
            
            _logger.LogWarning("Configuration key not found: {Key}", key);
            return default(T);
        }

        public void SetConfiguration(string key, object value)
        {
            lock (_lock)
            {
                var oldValue = _configuration.GetValueOrDefault(key);
                _configuration[key] = value;
                
                _logger.LogInformation("Configuration updated: {Key} = {Value}", key, value);
                NotifyConfigurationChange(key, oldValue, value);
            }
        }

        public bool HasConfiguration(string key)
        {
            return _configuration.ContainsKey(key);
        }

        public Dictionary<string, object> GetAllConfigurations()
        {
            return new Dictionary<string, object>(_configuration);
        }

        public void LoadConfiguration(string configFilePath)
        {
            try
            {
                // In a real implementation, this would load from file
                _logger.LogInformation("Loading configuration from: {FilePath}", configFilePath);
                _isInitialized = true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error loading configuration from: {FilePath}", configFilePath);
            }
        }

        private void InitializeDefaultConfiguration()
        {
            // Database Configuration
            SetConfiguration("Database.ConnectionString", "Server=localhost;Database=PoliMarket;Trusted_Connection=true;");
            SetConfiguration("Database.CommandTimeout", 30);
            SetConfiguration("Database.MaxPoolSize", 100);

            // Sales Configuration
            SetConfiguration("Sales.MaxDiscountPercentage", 0.30);
            SetConfiguration("Sales.TaxRate", 0.19);
            SetConfiguration("Sales.AllowNegativeInventory", false);
            SetConfiguration("Sales.DefaultPaymentMethod", "CreditCard");

            // Inventory Configuration
            SetConfiguration("Inventory.LowStockThreshold", 10);
            SetConfiguration("Inventory.AutoReorderEnabled", true);
            SetConfiguration("Inventory.ReorderQuantity", 50);

            // Authorization Configuration
            SetConfiguration("Authorization.MaxLoginAttempts", 3);
            SetConfiguration("Authorization.TokenExpirationMinutes", 60);
            SetConfiguration("Authorization.RequireEmailVerification", true);

            _logger.LogInformation("Default configuration initialized");
        }

        private void NotifyConfigurationChange(string key, object? oldValue, object newValue)
        {
            // In a real implementation, this could notify observers of configuration changes
            _logger.LogDebug("Configuration change notification: {Key} changed from {OldValue} to {NewValue}", 
                key, oldValue, newValue);
        }
    }

    public interface IConfigurationProvider
    {
        T GetConfiguration<T>(string key);
        bool HasConfiguration(string key);
        Dictionary<string, object> GetAllConfigurations();
    }
}
```

#### 4.3.2 Integration with Components
```csharp
namespace PoliMarket.Components.Sales
{
    public class VentasComponent : IVentasComponent
    {
        private readonly ConfigurationManager _configManager;
        private readonly ILogger<VentasComponent> _logger;
        // ... other dependencies

        public VentasComponent(ILogger<VentasComponent> logger)
        {
            _configManager = ConfigurationManager.GetInstance();
            _logger = logger;
            // ... other initializations
        }

        public async Task<ApiResponse<double>> CalculateTotalAsync(List<SaleDetailRequest> detalles, string clienteId)
        {
            try
            {
                // Get configuration values
                var maxDiscountPercentage = _configManager.GetConfiguration<double>("Sales.MaxDiscountPercentage");
                var taxRate = _configManager.GetConfiguration<double>("Sales.TaxRate");
                
                _logger.LogInformation("Using configuration - MaxDiscount: {MaxDiscount}, TaxRate: {TaxRate}", 
                    maxDiscountPercentage, taxRate);

                double subtotal = 0;

                foreach (var detalle in detalles)
                {
                    var producto = await _repository.GetProductByIdAsync(detalle.IdProducto);
                    if (producto == null) continue;

                    var lineTotal = producto.Precio * detalle.Cantidad;
                    
                    // Apply discount if within configured limits
                    if (detalle.Descuento > 0 && detalle.Descuento <= maxDiscountPercentage)
                    {
                        lineTotal -= lineTotal * detalle.Descuento;
                    }
                    
                    subtotal += lineTotal;
                }

                // Apply tax using configured rate
                var total = subtotal * (1 + taxRate);

                return ApiResponse<double>.SuccessResult(total, "Total calculado exitosamente");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error calculating total");
                return ApiResponse<double>.ErrorResult("Error interno del servidor", ex.Message);
            }
        }
    }
}
```

---

## 5. Command Pattern

### 5.1 Problema Identificado
**¿Cuál es el problema?**
Las operaciones complejas en el sistema actual (como procesar una venta que involucra múltiples pasos: validación, actualización de inventario, creación de registro) no tienen capacidad de deshacer cambios si algo falla a mitad del proceso. Además, no hay un registro de auditoría de las operaciones realizadas.

### 5.2 Por qué el Patrón Ayuda
**¿Por qué el patrón puede ayudar a solucionar el problema?**
El Command Pattern proporciona:
- **Encapsulación**: Operaciones complejas como objetos
- **Undo/Redo**: Capacidad de deshacer operaciones
- **Logging**: Registro completo de operaciones ejecutadas
- **Queuing**: Operaciones pueden ser encoladas y ejecutadas después
- **Macro commands**: Combinar múltiples comandos

### 5.3 Implementación del Patrón
**¿Cómo se puede implementar el patrón?**

#### 5.3.1 Command Interface
```csharp
namespace PoliMarket.Patterns.Command
{
    public interface ICommand
    {
        CommandResult Execute();
        CommandResult Undo();
        bool CanUndo();
        bool CanExecute();
        string GetCommandType();
        string GetCommandId();
        DateTime GetExecutionTime();
    }

    public class CommandResult
    {
        public bool Success { get; set; }
        public string Message { get; set; } = string.Empty;
        public Dictionary<string, object> Data { get; set; } = new();
        public long ExecutionTime { get; set; }
        public List<string> Errors { get; set; } = new();
        public List<string> Warnings { get; set; } = new();

        public void AddError(string error) => Errors.Add(error);
        public void AddWarning(string warning) => Warnings.Add(warning);
        public void AddData(string key, object value) => Data[key] = value;
    }
}
```
